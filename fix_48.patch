diff --git a/CMakeLists.txt b/CMakeLists.txt
index 848f26b..8e2e357 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -79,7 +79,7 @@ if (CMAKE_Fortran_COMPILER_ID STREQUAL "GNU")
     if (CMAKE_BUILD_TYPE STREQUAL "Debug")
         add_compile_options(
             -fcheck=all     -fbacktrace
-            -fimplicit-none -ffpe-trap=invalid,zero,overflow,underflow
+            -fimplicit-none
         )
     endif()
 
diff --git a/examples/2D_shockbubble/case.py b/examples/2D_shockbubble/case.py
index 35b462b..5296320 100644
--- a/examples/2D_shockbubble/case.py
+++ b/examples/2D_shockbubble/case.py
@@ -64,7 +64,7 @@ print(json.dumps({
     'bc_x%end'                     : -6,
     'bc_y%beg'                     : -6,
     'bc_y%end'                     : -6,
-    # ==========================================================================
+    # ===================================================   =======================
 
     # Formatted Database Files Structure Parameters ============================
     'format'                       : 1,
diff --git a/src/common/inline_conversions.fpp b/src/common/inline_conversions.fpp
new file mode 100644
index 0000000..f5cb631
--- /dev/null
+++ b/src/common/inline_conversions.fpp
@@ -0,0 +1,56 @@
+!>  This procedure calculates the speed of sound
+        !! @param pres Pressure
+        !! @param rho Cell averaged density
+        !! @param pi_inf Cell averaged liquid stiffness
+        !! @param gamma Cell averaged specific heat ratio
+        !! @param H Cell averaged enthalpy
+        !! @param adv Advection Variables
+        !! @param vel_sum Sum of all velocities
+        !! @param q_prim_vf Primitive vars in 1 direction
+        !! @param flg Helps determine which conditionals to be called.
+            ! flg >= 2: Check all conditionals
+            ! flg =  1: Check for alt_soundspeed, otherwise run the 3rd conditional block
+            ! flg = 0: Check for alt_soundspeed, otherwise use enthalpy
+        !! @param c Speed of sound
+        
+#:def compute_speed_of_sound(pres, rho, gamma, pi_inf, H, adv, vel_sum, q_prim_vf, j, k, l, flg, c)
+
+    if (alt_soundspeed .and. ${flg}$ >= 0) then 
+        blkmod1 = ((gammas(1) + 1d0)*${pres}$ + & 
+                    pi_infs(1))/gammas(1) 
+        blkmod2 = ((gammas(2) + 1d0)*${pres}$ + & 
+                    pi_infs(2))/gammas(2) 
+        ${c}$ = (1d0/(${rho}$*(${adv}$(1)/blkmod1 + ${adv}$(2)/blkmod2))) 
+    elseif (model_eqns == 3 .and. ${flg}$ >= 2) then 
+        ${c}$ = 0d0 
+!$acc loop seq 
+        do q = 1, num_fluids 
+            ${c}$ = ${c}$ + ${q_prim_vf}$(${j}$, ${k}$, ${l}$, q + advxb - 1)*(1d0/gammas(q) + 1d0)* & 
+                (${q_prim_vf}$(${j}$, ${k}$, ${l}$, E_idx) + pi_infs(q)/(gammas(q) + 1d0)) 
+        end do 
+        ${c}$ = ${c}$/${rho}$
+
+    elseif (((model_eqns == 4) .or. (model_eqns == 2 .and. bubbles) .or. ${flg}$ == 1) &
+            .and. ${flg}$ >= 1) then
+        ! Sound speed for bubble mmixture to order O(\alpha)
+
+        if (mpp_lim .and. (num_fluids > 1)) then
+            ${c}$ = (1d0/${gamma}$ + 1d0)* &
+                  (${pres}$ + ${pi_inf}$)/${rho}$
+        else
+            ${c}$ = &
+                (1d0/${gamma}$ + 1d0)* &    
+                (${pres}$ + ${pi_inf}$)/ &
+                (${rho}$*(1d0 - ${adv}$(num_fluids)))
+        end if
+    else 
+        ${c}$ = ((${H}$ - 5d-1*${vel_sum}$)/${gamma}$) 
+    end if 
+
+    if (mixture_err .and. ${c}$ < 0d0) then
+        ${c}$ = 100.d0*sgm_eps
+    else
+        ${c}$ = sqrt(${c}$)
+    end if
+        
+#:enddef compute_speed_of_sound
diff --git a/src/common/m_variables_conversion.fpp b/src/common/m_variables_conversion.fpp
index 4c2d9bf..c27083a 100644
--- a/src/common/m_variables_conversion.fpp
+++ b/src/common/m_variables_conversion.fpp
@@ -70,37 +70,8 @@ module m_variables_conversion
 
         end subroutine s_convert_xxxxx_to_mixture_variables
 
-        !> The abstract interface to the procedures that are used to compute the
-        !! Roe and the arithmetic average states. For additional information see:
-        !!                 1) s_compute_roe_average_state
-        !!                 2) s_compute_arithmetic_average_state
-        !! @param i Cell location first index
-        !! @param j Cell location second index
-        !! @param k Cell location third index
-        subroutine s_compute_abstract_average_state(i, j, k)
-
-            integer, intent(IN) :: i, j, k
-
-        end subroutine s_compute_abstract_average_state
-
     end interface ! ============================================================
 
-    !> @name  Left/right states
-    !> @{
-
-    !> @name Averaged states
-    !> @{
-    real(kind(0d0)), allocatable, dimension(:, :, :) :: rho_avg_sf !< averaged (Roe/arithmetic) density
-    real(kind(0d0)), allocatable, dimension(:) :: vel_avg    !< averaged (Roe/arithmetic) velocity
-    real(kind(0d0)) :: H_avg      !< averaged (Roe/arithmetic) enthalpy
-    type(scalar_field), allocatable, dimension(:) :: mf_avg_vf  !< averaged (Roe/arithmetic) mass fraction
-    real(kind(0d0)) :: gamma_avg  !< averaged (Roe/arithmetic) specific heat ratio
-    real(kind(0d0)), allocatable, dimension(:, :, :) :: c_avg_sf   !< averaged (Roe/arithmetic) speed of sound
-
-    real(kind(0d0)) :: alpha_avg !< averaging for bubbly mixture speed of sound
-    real(kind(0d0)) :: pres_avg  !< averaging for bubble mixture speed of sound
-    !> @}
-
     integer, public :: ixb, ixe, iyb, iye, izb, ize
     !$acc declare create(ixb, ixe, iyb, iye, izb, ize)
 
@@ -118,20 +89,15 @@ module m_variables_conversion
     integer :: is1b, is2b, is3b, is1e, is2e, is3e
     !$acc declare create(is1b, is2b, is3b, is1e, is2e, is3e)
 
-    real(kind(0d0)), allocatable, dimension(:, :, :), target, public :: rho_sf !< Scalar density function
-    real(kind(0d0)), allocatable, dimension(:, :, :), target, public :: gamma_sf !< Scalar sp. heat ratio function
-    real(kind(0d0)), allocatable, dimension(:, :, :), target, public :: pi_inf_sf !< Scalar liquid stiffness function   
+    real(kind(0d0)), allocatable, dimension(:, :, :), public :: rho_sf !< Scalar density function
+    real(kind(0d0)), allocatable, dimension(:, :, :), public :: gamma_sf !< Scalar sp. heat ratio function
+    real(kind(0d0)), allocatable, dimension(:, :, :), public :: pi_inf_sf !< Scalar liquid stiffness function   
 
     procedure(s_convert_xxxxx_to_mixture_variables), &
         pointer :: s_convert_to_mixture_variables => null() !<
     !! Pointer referencing the subroutine s_convert_mixture_to_mixture_variables
     !! or s_convert_species_to_mixture_variables, based on model equations choice 
 
-    procedure(s_compute_abstract_average_state), &
-        pointer :: s_compute_average_state => null() !<
-    !! Pointer to the subroutine utilized to calculate either the Roe or the
-    !! arithmetic average state variables, based on the chosen average state
-
 contains
 
     !>  This procedure conditionally calculates the appropriate pressure
@@ -144,12 +110,12 @@ contains
     subroutine s_compute_pressure(energy, alf, dyn_p, pi_inf, gamma, pres)      
 !$acc routine seq
 
-        real(kind(0d0)) :: energy, alf
+        real(kind(0d0)), intent(IN) :: energy, alf
 
         real(kind(0d0)), intent(IN) :: dyn_p
         real(kind(0d0)), intent(OUT) :: pres
 
-        real(kind(0d0)) :: pi_inf, gamma
+        real(kind(0d0)), intent(IN) :: pi_inf, gamma
 
         ! Depending on model_eqns and bubbles, the appropriate procedure
         ! for computing pressure is targeted by the procedure pointer
@@ -195,33 +161,18 @@ contains
         real(kind(0d0)), optional, intent(OUT) :: G_K
         real(kind(0d0)), optional, dimension(num_fluids), intent(IN) :: G
 
-        real(kind(0d0)), pointer :: rho_K, gamma_K, pi_inf_K
-
-        !> Post process requires rho_sf/gamma_sf/pi_inf_sf to be 
-            !! updated alongside of rho/gamma/pi_inf. Therefore, the
-            !! versions of these variables appended with '_K' represent
-            !! pointers that target the correct variable. At the end, 
-            !! rho/gamma/pi_inf are updated for post process.
-#ifdef MFC_POST_PROCESS
-        rho_K => rho_sf(i, j, k)
-        gamma_K =>  gamma_sf(i, j, k)
-        pi_inf_K => pi_inf_sf(i, j, k)
-#else
-        rho_K  => rho
-        gamma_K => gamma
-        pi_inf_K => pi_inf
-#endif
-
         ! Transfering the density, the specific heat ratio function and the
         ! liquid stiffness function, respectively
-        rho_K = q_vf(1)%sf(i, j, k)
-        gamma_K = q_vf(gamma_idx)%sf(i, j, k)
-        pi_inf_K = q_vf(pi_inf_idx)%sf(i, j, k)
+        rho = q_vf(1)%sf(i, j, k)
+        gamma = q_vf(gamma_idx)%sf(i, j, k)
+        pi_inf = q_vf(pi_inf_idx)%sf(i, j, k)
+
 
+        ! Post process requires rho_sf/gamma_sf/pi_inf_sf to also be updated
 #ifdef MFC_POST_PROCESS
-        rho = rho_K
-        gamma = gamma_K
-        pi_inf = pi_inf_K
+        rho_sf(i, j, k) = rho
+        gamma_sf(i, j, k) = gamma
+        pi_inf_sf(i, j, k) = pi_inf
 #endif
 
     end subroutine s_convert_mixture_to_mixture_variables ! ----------------
@@ -257,23 +208,6 @@ contains
 
         integer :: i
 
-        real(kind(0d0)), pointer :: rho_K, gamma_K, pi_inf_K
-
-        !> Post process requires rho_sf/gamma_sf/pi_inf_sf to be 
-            !! updated alongside of rho/gamma/pi_inf. Therefore, the
-            !! versions of these variables appended with '_K' represent
-            !! pointers that target the correct variable. At the end, 
-            !! rho/gamma/pi_inf are updated for post process.
-#ifdef MFC_POST_PROCESS
-        rho_K => rho_sf(j, k, l)
-        gamma_K =>  gamma_sf(j, k, l)
-        pi_inf_K => pi_inf_sf(j, k, l)
-#else
-        rho_K  => rho
-        gamma_K => gamma
-        pi_inf_K => pi_inf
-#endif
-
         ! Constraining the partial densities and the volume fractions within
         ! their physical bounds to make sure that any mixture variables that
         ! are derived from them result within the limits that are set by the
@@ -285,43 +219,44 @@ contains
         ! function as well as the liquid stiffness function, respectively
 
         if (model_eqns == 4) then
-            rho_K = q_vf(1)%sf(j, k, l)
-            gamma_K = fluid_pp(1)%gamma    !qK_vf(gamma_idx)%sf(i,j,k)
-            pi_inf_K = fluid_pp(1)%pi_inf   !qK_vf(pi_inf_idx)%sf(i,j,k)
+            rho = q_vf(1)%sf(j, k, l)
+            gamma = fluid_pp(1)%gamma    !qK_vf(gamma_idx)%sf(i,j,k)
+            pi_inf = fluid_pp(1)%pi_inf   !qK_vf(pi_inf_idx)%sf(i,j,k)
         else if ((model_eqns == 2) .and. bubbles) then
-            rho_K = 0d0; gamma_K = 0d0; pi_inf_K = 0d0
+            rho = 0d0; gamma = 0d0; pi_inf = 0d0
 
             if (mpp_lim .and. (num_fluids > 2)) then
                 do i = 1, num_fluids
-                    rho_K = rho_K + q_vf(i)%sf(j, k, l)
-                    gamma_K = gamma_K + q_vf(i + E_idx)%sf(j, k, l)*fluid_pp(i)%gamma
-                    pi_inf_K = pi_inf_K + q_vf(i + E_idx)%sf(j, k, l)*fluid_pp(i)%pi_inf
+                    rho = rho + q_vf(i)%sf(j, k, l)
+                    gamma = gamma + q_vf(i + E_idx)%sf(j, k, l)*fluid_pp(i)%gamma
+                    pi_inf = pi_inf + q_vf(i + E_idx)%sf(j, k, l)*fluid_pp(i)%pi_inf
                 end do
             else if (num_fluids == 2) then
-                rho_K = q_vf(1)%sf(j, k, l)
-                gamma_K = fluid_pp(1)%gamma
-                pi_inf_K = fluid_pp(1)%pi_inf
+                rho = q_vf(1)%sf(j, k, l)
+                gamma = fluid_pp(1)%gamma
+                pi_inf = fluid_pp(1)%pi_inf
             else if (num_fluids > 2) then
                 !TODO: This may need fixing for hypo + bubbles
                 do i = 1, num_fluids - 1 !leave out bubble part of mixture
-                    rho_K = rho_K + q_vf(i)%sf(j, k, l)
-                    gamma_K = gamma_K + q_vf(i + E_idx)%sf(j, k, l)*fluid_pp(i)%gamma
-                    pi_inf_K = pi_inf_K + q_vf(i + E_idx)%sf(j, k, l)*fluid_pp(i)%pi_inf
+                    rho = rho + q_vf(i)%sf(j, k, l)
+                    gamma = gamma + q_vf(i + E_idx)%sf(j, k, l)*fluid_pp(i)%gamma
+                    pi_inf = pi_inf + q_vf(i + E_idx)%sf(j, k, l)*fluid_pp(i)%pi_inf
                 end do
-                !rho_K    = qK_vf(1)%sf(j,k,l)
+                !rho    = qK_vf(1)%sf(j,k,l)
                 !gamma_K  = fluid_pp(1)%gamma
                 !pi_inf_K = fluid_pp(1)%pi_inf
             else
-                rho_K = q_vf(1)%sf(j, k, l)
-                gamma_K = fluid_pp(1)%gamma
-                pi_inf_K = fluid_pp(1)%pi_inf
+                rho = q_vf(1)%sf(j, k, l)
+                gamma = fluid_pp(1)%gamma
+                pi_inf = fluid_pp(1)%pi_inf
             end if
         end if
 
+        ! Post process requires rho_sf/gamma_sf/pi_inf_sf to also be updated
 #ifdef MFC_POST_PROCESS
-        rho = rho_K
-        gamma = gamma_K
-        pi_inf = pi_inf_K
+        rho_sf(i, j, k) = rho
+        gamma_sf(i, j, k) = gamma
+        pi_inf_sf(i, j, k) = pi_inf
 #endif
 
     end subroutine s_convert_species_to_mixture_variables_bubbles ! ----------------
@@ -359,23 +294,6 @@ contains
 
         integer :: i, j !< Generic loop iterator
 
-        real(kind(0d0)), pointer :: rho_K, gamma_K, pi_inf_K
-
-        !> Post process requires rho_sf/gamma_sf/pi_inf_sf to be 
-            !! updated alongside of rho/gamma/pi_inf. Therefore, the
-            !! versions of these variables appended with '_K' represent
-            !! pointers that target the correct variable. At the end, 
-            !! rho/gamma/pi_inf are updated for post process.
-#ifdef MFC_POST_PROCESS
-        rho_K => rho_sf(k, l, r)
-        gamma_K =>  gamma_sf(k, l, r)
-        pi_inf_K => pi_inf_sf(k, l, r)
-#else
-        rho_K  => rho
-        gamma_K => gamma
-        pi_inf_K => pi_inf
-#endif
-
         ! Computing the density, the specific heat ratio function and the
         ! liquid stiffness function, respectively
 
@@ -397,12 +315,12 @@ contains
 
         ! Calculating the density, the specific heat ratio function and the
         ! liquid stiffness function, respectively, from the species analogs
-        rho_K = 0d0; gamma_K = 0d0; pi_inf_K = 0d0
+        rho = 0d0; gamma = 0d0; pi_inf = 0d0
 
         do i = 1, num_fluids
-            rho_K = rho_K + alpha_rho_K(i)
-            gamma_K = gamma_K + alpha_K(i)*gammas(i)
-            pi_inf_K = pi_inf_K + alpha_K(i)*pi_infs(i)
+            rho = rho + alpha_rho_K(i)
+            gamma = gamma + alpha_K(i)*gammas(i)
+            pi_inf = pi_inf + alpha_K(i)*pi_infs(i)
         end do
 
 #ifdef MFC_SIMULATION
@@ -429,10 +347,11 @@ contains
             G_K = max(0d0, G_K)
         end if
 
+        ! Post process requires rho_sf/gamma_sf/pi_inf_sf to also be updated
 #ifdef MFC_POST_PROCESS
-        rho = rho_K
-        gamma = gamma_K
-        pi_inf = pi_inf_K
+        rho_sf(i, j, k) = rho
+        gamma_sf(i, j, k) = gamma
+        pi_inf_sf(i, j, k) = pi_inf
 #endif
 
     end subroutine s_convert_species_to_mixture_variables ! ----------------
diff --git a/src/post_process/m_global_parameters.f90 b/src/post_process/m_global_parameters.f90
index 1c201bd..c77e8b3 100644
--- a/src/post_process/m_global_parameters.f90
+++ b/src/post_process/m_global_parameters.f90
@@ -389,7 +389,7 @@ contains
             if (bubbles) then
                 alf_idx = adv_idx%end
             else
-                alf_idx = 0
+                alf_idx = 1
             end if
 
             if (bubbles) then
diff --git a/src/pre_process/m_global_parameters.fpp b/src/pre_process/m_global_parameters.fpp
index 867c016..2d686b6 100644
--- a/src/pre_process/m_global_parameters.fpp
+++ b/src/pre_process/m_global_parameters.fpp
@@ -25,6 +25,7 @@ module m_global_parameters
     integer, parameter :: name_len = 50   !< Maximum name length
     real(kind(0d0)), parameter :: dflt_real = -1d6 !< Default real value
     integer, parameter :: dflt_int = -100 !< Default integer value
+    real(kind(0d0)), parameter :: sgm_eps = 1d-16 !< Segmentation tolerance
     character(LEN=path_len) :: case_dir             !< Case folder location
     logical :: old_grid             !< Use existing grid data
     logical :: old_ic               !< Use existing IC data
@@ -394,7 +395,7 @@ contains
             if (bubbles) then
                 alf_idx = adv_idx%end
             else
-                alf_idx = 0
+                alf_idx = 1
             end if
 
             if (bubbles) then
diff --git a/src/simulation/inline_riemann.fpp b/src/simulation/inline_riemann.fpp
index 22943d7..5d9ebfb 100644
--- a/src/simulation/inline_riemann.fpp
+++ b/src/simulation/inline_riemann.fpp
@@ -46,3 +46,4 @@ if (avg_state == 2) then
 end if
 
 #:enddef compute_average_state
+
diff --git a/src/simulation/m_cbc.fpp b/src/simulation/m_cbc.fpp
index 5f55b4d..2ec7ffd 100644
--- a/src/simulation/m_cbc.fpp
+++ b/src/simulation/m_cbc.fpp
@@ -17,6 +17,9 @@
 !!                           7) Supersonic Inflow
 !!                           8) Supersonic Outflow
 !!              Please refer to Thompson (1987, 1990) for detailed descriptions.
+
+#:include 'inline_conversions.fpp'
+
 module m_cbc
 
     ! Dependencies =============================================================
@@ -86,7 +89,7 @@ module m_cbc
     real(kind(0d0)) :: H           !< Cell averaged enthalpy
     real(kind(0d0)), allocatable, dimension(:) :: adv         !< Cell averaged advected variables
     real(kind(0d0)), allocatable, dimension(:) :: mf          !< Cell averaged mass fraction
-    real(kind(0d0)) :: gamma       !< Cell averaged specific heat ratio
+    real(kind(0d0)) :: gamma        !< Cell averaged specific heat ratio
     real(kind(0d0)) :: pi_inf      !< Cell averaged liquid stiffness
     real(kind(0d0)) :: c           !< Cell averaged speed of sound
     real(kind(0d0)), dimension(2) :: Re          !< Cell averaged Reynolds numbers
@@ -677,7 +680,7 @@ contains
 
         real(kind(0d0)) :: vel_K_sum, vel_dv_dt_sum
 
-        integer :: i, j, k, r !< Generic loop iterators
+        integer :: i, j, k, r, q !< Generic loop iterators
 
         real(kind(0d0)) :: blkmod1, blkmod2 !< Fluid bulk modulus for Wood mixture sound speed
 
@@ -820,41 +823,18 @@ contains
                         call s_convert_species_to_mixture_variables_acc(rho, gamma, pi_inf, adv, alpha_rho, Re_cbc, 0, k, r)
                     end if
 
-                    E = gamma*pres + pi_inf + 5d-1*rho*vel_K_sum
-
-                    H = (E + pres)/rho
-
                     !$acc loop seq
                     do i = 1, contxe
                         mf(i) = alpha_rho(i)/rho
                     end do
 
-                    ! Compute mixture sound speed
-                    if (alt_soundspeed) then
-                        blkmod1 = ((gammas(1) + 1d0)*pres + &
-                                   pi_infs(1))/gammas(1)
-                        blkmod2 = ((gammas(2) + 1d0)*pres + &
-                                   pi_infs(2))/gammas(2)
-                        c = (1d0/(rho*(adv(1)/blkmod1 + adv(2)/blkmod2)))
-                    elseif (model_eqns == 3) then
-                        c = 0d0
-                        !$acc loop seq
-                        do i = 1, num_fluids
-                            c = c + q_prim_rs${XYZ}$_vf(0, k, r, i + advxb - 1)*(1d0/gammas(i) + 1d0)* &
-                                (pres + pi_infs(i)/(gammas(i) + 1d0))
-                        end do
-                        c = c/rho
-                    else
-                        c = ((H - 5d-1*vel_K_sum)/gamma)
-                    end if
+                    E = gamma*pres + pi_inf + 5d-1*rho*vel_K_sum
 
-                    c = sqrt(c)
+                    H = (E + pres)/rho
 
-                    !                  IF (mixture_err .AND. c < 0d0) THEN
-                    !                    c = sgm_eps
-                    !                  ELSE
-                    !                    c = SQRT(c)
-                    !                  END IF
+                    ! Compute mixture sound speed
+                    @:compute_speed_of_sound(pres, rho, gamma, pi_inf, H, adv, vel_K_sum, &
+                                    q_prim_rs${XYZ}$_vf, 0, k, r, 2, c)
 
                     ! ============================================================
 
diff --git a/src/simulation/m_data_output.fpp b/src/simulation/m_data_output.fpp
index 18dfa8d..e77782d 100644
--- a/src/simulation/m_data_output.fpp
+++ b/src/simulation/m_data_output.fpp
@@ -3,6 +3,7 @@
 !! @brief Contains module m_data_output
 
 #:include 'macros.fpp'
+#:include 'inline_conversions.fpp'
 
 !> @brief The primary purpose of this module is to output the grid and the
 !!              conservative variables data at the chosen time-step interval. In
@@ -441,6 +442,8 @@ contains
     subroutine s_write_serial_data_files(q_cons_vf, t_step) ! ---------------------
 
         type(scalar_field), dimension(sys_size), intent(IN) :: q_cons_vf
+        type(scalar_field), dimension(sys_size) :: q_prim_vf
+
         integer, intent(IN) :: t_step
 
         character(LEN=path_len + 2*name_len) :: t_step_dir !<
@@ -536,6 +539,13 @@ contains
 
         if (.not. file_exist) call s_create_directory(trim(t_step_dir))
 
+        if (prim_vars_wrt .or. (n == 0 .and. p == 0)) then
+            do i = 1, sys_size
+                allocate(q_prim_vf(i)%sf(ixb:ixe, iyb:iye, izb:ize))
+            end do
+            call s_convert_conservative_to_primitive_variables(q_cons_vf, q_prim_vf)
+        end if
+
         !1D
         if (n == 0 .and. p == 0) then
 
@@ -545,87 +555,13 @@ contains
 
                     open (2, FILE=trim(file_path))
                     do j = 0, m
-                        call s_convert_to_mixture_variables(q_cons_vf, j, 0, 0, rho, gamma, pi_inf, Re, &
-                                                            G, fluid_pp(:)%G)
-                        lit_gamma = 1d0/gamma + 1d0
-
                         if (((i >= cont_idx%beg) .and. (i <= cont_idx%end)) &
                             .or. &
                             ((i >= adv_idx%beg) .and. (i <= adv_idx%end)) &
                             ) then
                             write (2, FMT) x_cb(j), q_cons_vf(i)%sf(j, 0, 0)
-                        else if (i == mom_idx%beg) then !u
-                            write (2, FMT) x_cb(j), q_cons_vf(mom_idx%beg)%sf(j, 0, 0)/rho
-                        else if (i == stress_idx%beg) then !tau_e
-                            write (2, FMT) x_cb(j), q_cons_vf(stress_idx%beg)%sf(j, 0, 0)/rho
-                        else if (i == E_idx) then !p
-                            if (model_eqns == 4) then
-                                !Tait pressure from density
-                                write (2, FMT) x_cb(j), &
-                                    (pref + pi_inf)*( &
-                                    (q_cons_vf(1)%sf(j, 0, 0)/ &
-                                     (rhoref*(1.d0 - q_cons_vf(4)%sf(j, 0, 0))) &
-                                     )**lit_gamma) &
-                                    - pi_inf
-                            else if (hypoelasticity) then
-                                ! elastic contribution to energy
-                                E_e = 0d0
-                                do k = stress_idx%beg, stress_idx%end
-                                    if (G > 1000) then
-                                        E_e = E_e + ((q_cons_vf(stress_idx%beg)%sf(j, 0, 0)/rho)**2d0) &
-                                              /(4d0*G)
-                                        ! Additional terms in 2D and 3D
-                                        if ((k == stress_idx%beg + 1) .or. &
-                                            (k == stress_idx%beg + 3) .or. &
-                                            (k == stress_idx%beg + 4)) then
-                                            E_e = E_e + ((q_cons_vf(stress_idx%beg)%sf(j, 0, 0)/rho)**2d0) &
-                                                  /(4d0*G)
-                                        end if
-                                    end if
-                                end do
-
-                                write (2, FMT) x_cb(j), &
-                                    ( &
-                                    q_cons_vf(E_idx)%sf(j, 0, 0) - &
-                                    0.5d0*(q_cons_vf(mom_idx%beg)%sf(j, 0, 0)**2.d0)/rho - &
-                                    pi_inf - E_e &
-                                    )/gamma
-                            else if (model_eqns == 2 .and. (bubbles .neqv. .true.)) then
-                                !Stiffened gas pressure from energy
-                                write (2, FMT) x_cb(j), &
-                                    ( &
-                                    q_cons_vf(E_idx)%sf(j, 0, 0) - &
-                                    0.5d0*(q_cons_vf(mom_idx%beg)%sf(j, 0, 0)**2.d0)/rho - &
-                                    pi_inf &
-                                    )/gamma
-                            else
-                                !Stiffened gas pressure from energy with bubbles
-                                write (2, FMT) x_cb(j), &
-                                    ( &
-                                    (q_cons_vf(E_idx)%sf(j, 0, 0) - &
-                                     0.5d0*(q_cons_vf(mom_idx%beg)%sf(j, 0, 0)**2.d0)/rho)/ &
-                                    (1.d0 - q_cons_vf(alf_idx)%sf(j, 0, 0)) - &
-                                    pi_inf &
-                                    )/gamma
-                            end if
-                        else if ((i >= bub_idx%beg) .and. (i <= bub_idx%end) .and. bubbles) then
-                            do k = 1, nb
-                                nRtmp(k) = q_cons_vf(bub_idx%rs(k))%sf(j, 0, 0)
-                            end do
-
-                            !call s_comp_n_from_cons(q_cons_vf(alf_idx)%sf(j, 0, 0), nRtmp, nbub)
-
-                            vftmp = q_cons_vf(alf_idx)%sf(j, 0, 0)
-
-                            nR3 = 0d0
-
-                            do k = 1, nb
-                                nR3 = nR3 + weight(k)*(nRtmp(k)**3d0)
-                            end do
-
-                            nbub = DSQRT((4.d0*pi/3.d0)*nR3/vftmp)
-
-                            write (2, FMT) x_cb(j), q_cons_vf(i)%sf(j, 0, 0)/nbub
+                        else
+                            write (2, FMT) x_cb(j), q_prim_vf(i)%sf(j, 0, 0)
                         end if
                     end do
                     close (2)
@@ -662,6 +598,29 @@ contains
                 end do
                 close (2)
             end do
+
+            if (prim_vars_wrt) then
+                do i = 1, sys_size
+                    write (file_path, '(A,I0,A,I2.2,A,I6.6,A)') trim(t_step_dir)//'/prim.', i, '.', proc_rank, '.', t_step, '.dat'
+
+                    open (2, FILE=trim(file_path))
+
+                    do j = 0, m
+                        do k = 0, n
+                            if (((i >= cont_idx%beg) .and. (i <= cont_idx%end)) &
+                                .or. &
+                                ((i >= adv_idx%beg) .and. (i <= adv_idx%end)) &
+                                ) then
+                                write (2, FMT) x_cb(j), y_cb(k), q_cons_vf(i)%sf(j, k, 0)
+                            else
+                                write (2, FMT) x_cb(j), y_cb(k), q_prim_vf(i)%sf(j, k, 0)
+                            end if
+                        end do
+                        write (2, *)
+                    end do
+                    close (2)
+                end do
+            end if
         end if
 
         if (precision == 1) then
@@ -686,6 +645,32 @@ contains
                 end do
                 close (2)
             end do
+
+            if (prim_vars_wrt) then
+                do i = 1, sys_size
+                    write (file_path, '(A,I0,A,I2.2,A,I6.6,A)') trim(t_step_dir)//'/prim.', i, '.', proc_rank, '.', t_step, '.dat'
+
+                    open (2, FILE=trim(file_path))
+
+                    do j = 0, m
+                        do k = 0, n
+                            do l = 0, p
+                                if (((i >= cont_idx%beg) .and. (i <= cont_idx%end)) &
+                                    .or. &
+                                    ((i >= adv_idx%beg) .and. (i <= adv_idx%end)) &
+                                    ) then
+                                    write (2, FMT) x_cb(j), y_cb(k), z_cb(l), q_cons_vf(i)%sf(j, k, l)
+                                else
+                                    write (2, FMT) x_cb(j), y_cb(k), z_cb(l), q_prim_vf(i)%sf(j, k, l)  
+                                end if
+                            end do
+                            write (2, *)
+                        end do
+                        write (2, *)
+                    end do
+                    close (2)
+                end do
+            end if
         end if
 
     end subroutine s_write_serial_data_files ! ------------------------------------
@@ -815,8 +800,9 @@ contains
         real(kind(0d0)), dimension(2) :: Re
         real(kind(0d0)) :: E_e
         real(kind(0d0)), dimension(6) :: tau_e
+        real(kind(0d0)), dimension(1:1, 1:1, 1:1, 1:1) :: q_prim_redundant
 
-        integer :: i, j, k, l, s !< Generic loop iterator
+        integer :: i, j, k, l, s, q !< Generic loop iterator
 
         real(kind(0d0)) :: nondim_time !< Non-dimensional time
 
@@ -888,15 +874,14 @@ contains
                         vel(s) = q_cons_vf(cont_idx%end + s)%sf(j - 2, k, l)/rho
                     end do
 
+                    call s_compute_pressure(q_cons_vf(1)%sf(j - 2, k, l), &
+                        q_cons_vf(alf_idx)%sf(j - 2, k, l), &
+                        0.5d0*(q_cons_vf(2)%sf(j - 2, k, l)**2.d0)/q_cons_vf(1)%sf(j - 2, k, l), &
+                        pi_inf, gamma, pres)
+
                     if (model_eqns == 4) then
                         lit_gamma = 1d0/fluid_pp(1)%gamma + 1d0
 
-                        !Tait pressure from density
-                        pres = (pref + pi_inf)*( &
-                               (q_cons_vf(1)%sf(j - 2, k, l)/ &
-                                (rhoref*(1.d0 - q_cons_vf(4)%sf(j - 2, k, l))) &
-                                )**lit_gamma) &
-                               - pi_inf
                     else if (hypoelasticity) then
                         ! calculate elastic contribution to Energy
                         E_e = 0d0
@@ -920,22 +905,6 @@ contains
                                0.5d0*(q_cons_vf(mom_idx%beg)%sf(j - 2, k, l)**2.d0)/rho - &
                                pi_inf - E_e &
                                )/gamma
-
-                    else if (model_eqns == 2 .and. (bubbles .neqv. .true.)) then
-                        !Stiffened gas pressure from energy
-                        pres = ( &
-                               q_cons_vf(E_idx)%sf(j - 2, k, l) - &
-                               0.5d0*(q_cons_vf(2)%sf(j - 2, k, l)**2.d0)/q_cons_vf(1)%sf(j - 2, k, l) - &
-                               pi_inf &
-                               )/gamma
-                    else
-                        !Stiffened gas pressure from energy with bubbles
-                        pres = ( &
-                               (q_cons_vf(E_idx)%sf(j - 2, k, l) - &
-                                0.5d0*(q_cons_vf(mom_idx%beg)%sf(j - 2, k, l)**2.d0)/rho)/ &
-                               (1.d0 - q_cons_vf(alf_idx)%sf(j - 2, k, l)) - &
-                               pi_inf &
-                               )/gamma
                     end if
 
                     if (bubbles) then
@@ -984,25 +953,10 @@ contains
                         ptot = pres - ptilde
                     end if
 
-                    ! Compute mixture sound speed
-                    if (alt_soundspeed) then
-                        do s = 1, num_fluids
-                            alpha(s) = q_cons_vf(E_idx + s)%sf(j - 2, k, l)
-                        end do
-                        blkmod1 = ((fluid_pp(1)%gamma + 1d0)*pres + &
-                                   fluid_pp(1)%pi_inf)/fluid_pp(1)%gamma
-                        blkmod2 = ((fluid_pp(2)%gamma + 1d0)*pres + &
-                                   fluid_pp(2)%pi_inf)/fluid_pp(2)%gamma
-                        c = (1d0/(rho*(alpha(1)/blkmod1 + alpha(2)/blkmod2)))
-                    else
-                        c = (((gamma + 1d0)*pres + pi_inf)/(gamma*rho))
-                    end if
-
-                    if (mixture_err .and. c < 0d0) then
-                        c = sgm_eps
-                    else
-                        c = sqrt(c)
-                    end if
+                    ! Compute mixture sound Speed
+                    @:compute_speed_of_sound(pres, rho, gamma, pi_inf, &
+                    ((gamma + 1d0)*pres + pi_inf)/rho, alpha, 0d0, q_prim_redundant, &
+                    j - 2, k, l, 0, c)
 
                     accel = accel_mag(j - 2, k, l)
                 end if
@@ -1031,15 +985,13 @@ contains
                             vel(s) = q_cons_vf(cont_idx%end + s)%sf(j - 2, k - 2, l)/rho
                         end do
 
+                        call s_compute_pressure(q_cons_vf(1)%sf(j - 2, k - 2, l), &
+                            q_cons_vf(alf_idx)%sf(j - 2, k - 2, l), &
+                            0.5d0*(q_cons_vf(2)%sf(j - 2, k - 2, l)**2.d0)/q_cons_vf(1)%sf(j - 2, k - 2, l), &
+                            pi_inf, gamma, pres)
+
                         if (model_eqns == 4) then
                             lit_gamma = 1d0/fluid_pp(1)%gamma + 1d0
-
-                            !Tait pressure from density
-                            pres = (pref + pi_inf)*( &
-                                   (q_cons_vf(1)%sf(j - 2, k - 2, l)/ &
-                                    (rhoref*(1.d0 - q_cons_vf(4)%sf(j - 2, k - 2, l))) &
-                                    )**lit_gamma) &
-                                   - pi_inf
                         else if (hypoelasticity) then
                             ! calculate elastic contribution to Energy
                             E_e = 0d0
@@ -1066,24 +1018,6 @@ contains
                                    0.5d0*(q_cons_vf(mom_idx%beg)%sf(j - 2, k - 2, l)**2.d0)/rho - &
                                    pi_inf - E_e &
                                    )/gamma
-
-                        else if (model_eqns == 2 .and. (bubbles .neqv. .true.)) then
-                            !Stiffened gas pressure from energy
-                            pres = ( &
-                                   q_cons_vf(E_idx)%sf(j - 2, k - 2, l) - &
-                                   0.5d0*((q_cons_vf(2)%sf(j - 2, k - 2, l)**2.d0 + &
-                                           q_cons_vf(3)%sf(j - 2, k - 2, l)**2.d0)/q_cons_vf(1)%sf(j - 2, k - 2, l)) - &
-                                   pi_inf &
-                                   )/gamma
-                        else
-                            !Stiffened gas pressure from energy with bubbles
-                            pres = ( &
-                                   (q_cons_vf(E_idx)%sf(j - 2, k - 2, l) - &
-                                    0.5d0*(q_cons_vf(2)%sf(j - 2, k - 2, l)**2.d0 + q_cons_vf(3)%sf(j - 2, k - 2, l)**2.d0) &
-                                    /q_cons_vf(1)%sf(j - 2, k - 2, l))/ &
-                                   (1.d0 - q_cons_vf(alf_idx)%sf(j - 2, k - 2, l)) - &
-                                   pi_inf &
-                                   )/gamma
                         end if
 
                         if (bubbles) then
@@ -1106,24 +1040,9 @@ contains
                         end if
 
                         ! Compute mixture sound speed
-                        if (alt_soundspeed) then
-                            do s = 1, num_fluids
-                                alpha(s) = q_cons_vf(E_idx + s)%sf(j - 2, k - 2, l)
-                            end do
-                            blkmod1 = ((fluid_pp(1)%gamma + 1d0)*pres + &
-                                       fluid_pp(1)%pi_inf)/fluid_pp(1)%gamma
-                            blkmod2 = ((fluid_pp(2)%gamma + 1d0)*pres + &
-                                       fluid_pp(2)%pi_inf)/fluid_pp(2)%gamma
-                            c = (1d0/(rho*(alpha(1)/blkmod1 + alpha(2)/blkmod2)))
-                        else
-                            c = (((gamma + 1d0)*pres + pi_inf)/(gamma*rho))
-                        end if
-
-                        if (mixture_err .and. c < 0d0) then
-                            c = sgm_eps
-                        else
-                            c = sqrt(c)
-                        end if
+                        @:compute_speed_of_sound(pres, rho, gamma, pi_inf, &
+                        ((gamma + 1d0)*pres + pi_inf)/rho, alpha, 0d0, q_prim_redundant, &
+                        j - 2, k - 2, l, 0, c)
 
                         accel = accel_mag(j - 2, k - 2, l)
                     end if
@@ -1162,24 +1081,9 @@ contains
                             pres = (q_cons_vf(E_idx)%sf(j - 2, k - 2, l - 2) - 0.5d0*rho*dot_product(vel, vel) - pi_inf)/gamma
 
                             ! Compute mixture sound speed
-                            if (alt_soundspeed) then
-                                do s = 1, num_fluids
-                                    alpha(s) = q_cons_vf(E_idx + s)%sf(j - 2, k - 2, l - 2)
-                                end do
-                                blkmod1 = ((fluid_pp(1)%gamma + 1d0)*pres + &
-                                           fluid_pp(1)%pi_inf)/fluid_pp(1)%gamma
-                                blkmod2 = ((fluid_pp(2)%gamma + 1d0)*pres + &
-                                           fluid_pp(2)%pi_inf)/fluid_pp(2)%gamma
-                                c = (1d0/(rho*(alpha(1)/blkmod1 + alpha(2)/blkmod2)))
-                            else
-                                c = (((gamma + 1d0)*pres + pi_inf)/(gamma*rho))
-                            end if
-
-                            if (mixture_err .and. c < 0d0) then
-                                c = sgm_eps
-                            else
-                                c = sqrt(c)
-                            end if
+                            @:compute_speed_of_sound(pres, rho, gamma, pi_inf, &
+                            ((gamma + 1d0)*pres + pi_inf)/rho, alpha, 0d0, q_prim_redundant, &
+                            j - 2, k - 2, l - 2, 0, c)
 
                             accel = accel_mag(j - 2, k - 2, l - 2)
                         end if
diff --git a/src/simulation/m_global_parameters.fpp b/src/simulation/m_global_parameters.fpp
index 71b42b1..69c69f3 100644
--- a/src/simulation/m_global_parameters.fpp
+++ b/src/simulation/m_global_parameters.fpp
@@ -102,6 +102,7 @@ module m_global_parameters
     logical :: mpp_lim        !< Mixture physical parameters (MPP) limits
     integer :: time_stepper   !< Time-stepper algorithm
     integer :: weno_vars      !< WENO-reconstructed state variables type
+    logical :: prim_vars_wrt
 
     #:if MFC_CASE_OPTIMIZATION
         integer, parameter :: weno_polyn = ${weno_polyn}$ !< Degree of the WENO polynomials (polyn)
@@ -535,7 +536,7 @@ contains
                 if (bubbles) then
                     alf_idx = adv_idx%end
                 else
-                    alf_idx = 0
+                    alf_idx = 1
                 end if
 
                 if (bubbles) then
@@ -637,6 +638,7 @@ contains
                 E_idx = mom_idx%end + 1
                 adv_idx%beg = E_idx + 1
                 adv_idx%end = E_idx + num_fluids
+                alf_idx = adv_idx%end
                 internalEnergies_idx%beg = adv_idx%end + 1
                 internalEnergies_idx%end = adv_idx%end + num_fluids
                 sys_size = internalEnergies_idx%end
@@ -649,7 +651,7 @@ contains
                 adv_idx%beg = E_idx + 1
                 adv_idx%end = adv_idx%beg !one volume advection equation
                 alf_idx = adv_idx%end
-                sys_size = alf_idx !adv_idx%end
+                sys_size = adv_idx%end
 
                 if (bubbles) then
                     bub_idx%beg = sys_size + 1
diff --git a/src/simulation/m_mpi_proxy.fpp b/src/simulation/m_mpi_proxy.fpp
index a543d74..00926aa 100644
--- a/src/simulation/m_mpi_proxy.fpp
+++ b/src/simulation/m_mpi_proxy.fpp
@@ -207,7 +207,8 @@ contains
             & 'mapped_weno', 'mp_weno', 'cu_mpi', 'weno_flat', 'riemann_flat', &
             & 'weno_Re_flux', 'alt_soundspeed', 'null_weights', 'mixture_err', &
             & 'parallel_io', 'hypoelasticity', 'bubbles', 'polytropic',        &
-            & 'polydisperse', 'qbmm', 'monopole', 'probe_wrt', 'integral_wrt' ]
+            & 'polydisperse', 'qbmm', 'monopole', 'probe_wrt', 'integral_wrt', &
+            & 'prim_vars_wrt']
             call MPI_BCAST(${VAR}$, 1, MPI_LOGICAL, 0, MPI_COMM_WORLD, ierr)
         #:endfor
 
diff --git a/src/simulation/m_riemann_solvers.fpp b/src/simulation/m_riemann_solvers.fpp
index a3fc36f..cbcf038 100644
--- a/src/simulation/m_riemann_solvers.fpp
+++ b/src/simulation/m_riemann_solvers.fpp
@@ -18,6 +18,7 @@
 !!                  2) Harten-Lax-van Leer-Contact (HLLC)
 !!                  3) Exact
 #:include 'inline_riemann.fpp'
+#:include 'inline_conversions.fpp'
 
 module m_riemann_solvers
 
@@ -309,6 +310,8 @@ module m_riemann_solvers
     !> @}
     real(kind(0d0)) :: xi_L, xi_R
 
+    real(kind(0d0)) :: start, finish
+
 !$acc declare create(s_L, s_R, s_S, rho_Star, E_Star, p_Star, p_K_Star, s_M, s_P, xi_M, xi_P, xi_L, xi_R)
 
     procedure(s_abstract_riemann_solver), &
@@ -586,82 +589,20 @@ contains
                             
                             @:compute_average_state()
 
-                            if (mixture_err) then
-                                if ((H_avg - 5d-1*vel_avg_rms) < 0d0) then
-                                    c_avg = sgm_eps
-                                else
-                                    c_avg = sqrt((H_avg - 5d-1*vel_avg_rms)/gamma_avg)
-                                end if
-                            else
-                                c_avg = sqrt((H_avg - 5d-1*vel_avg_rms)/gamma_avg)
-                            end if
-
-                            if (alt_soundspeed) then
-                                blkmod1 = ((gammas(1) + 1d0)*pres_L + &
-                                           pi_infs(1))/gammas(1)
-
-                                blkmod2 = ((gammas(2) + 1d0)*pres_L + &
-                                           pi_infs(2))/gammas(2)
-
-                                c_L = 1d0/(rho_L*(alpha_L(1)/blkmod1 + alpha_L(2)/blkmod2))
-
-                                blkmod1 = ((gammas(1) + 1d0)*pres_R + &
-                                           pi_infs(1))/gammas(1)
-
-                                blkmod2 = ((gammas(2) + 1d0)*pres_R + &
-                                           pi_infs(2))/gammas(2)
-
-                                c_R = 1d0/(rho_R*(alpha_R(1)/blkmod1 + alpha_R(2)/blkmod2))
-                            elseif (model_eqns == 3) then
-                                c_L = 0d0
-                                c_R = 0d0
-
-                                !$acc loop seq
-                                do i = 1, num_fluids
-                                    c_L = c_L + qL_prim_rs${XYZ}$_vf(j, k, l, i + advxb - 1)*(1d0/gammas(i) + 1d0)* &
-                                          (qL_prim_rs${XYZ}$_vf(j, k, l, E_idx) + pi_infs(i)/(gammas(i) + 1d0))
-
-                                    c_R = c_R + qR_prim_rs${XYZ}$_vf(j + 1, k, l, i + advxb - 1)*(1d0/gammas(i) + 1d0)* &
-                                          (qR_prim_rs${XYZ}$_vf(j + 1, k, l, E_idx) + pi_infs(i)/(gammas(i) + 1d0))
-                                end do
+                            @:compute_speed_of_sound(pres_L, rho_L, gamma_L, pi_inf_L, H_L, alpha_L, &
+                                    vel_L_rms, qL_prim_rs${XYZ}$_vf, j, k, l, 2, c_L)
 
-                                c_L = c_L/rho_L
-                                c_R = c_R/rho_R
-                            elseif ((model_eqns == 4) .or. (model_eqns == 2 .and. bubbles)) then
-                                ! Sound speed for bubble mmixture to order O(\alpha)
+                            @:compute_speed_of_sound(pres_L, rho_L, gamma_L, pi_inf_L, H_L, alpha_L, &
+                                    vel_L_rms, qL_prim_rs${XYZ}$_vf, j, k, l, 2, c_L)
 
-                                if (mpp_lim .and. (num_fluids > 1)) then
-                                    c_L = (1d0/gamma_L + 1d0)* &
-                                          (pres_L + pi_inf_L)/rho_L
-                                    c_R = (1d0/gamma_R + 1d0)* &
-                                          (pres_R + pi_inf_R)/rho_R
-                                else
-                                    c_L = &
-                                        (1d0/gamma_L + 1d0)* &
-                                        (pres_L + pi_inf_L)/ &
-                                        (rho_L*(1d0 - alpha_L(num_fluids)))
-                                    c_R = &
-                                        (1d0/gamma_R + 1d0)* &
-                                        (pres_R + pi_inf_R)/ &
-                                        (rho_R*(1d0 - alpha_R(num_fluids)))
-                                end if
-                            else
-                                c_L = ((H_L - 5d-1*vel_L_rms)/gamma_L)
+                            @:compute_speed_of_sound(pres_R, rho_R, gamma_R, pi_inf_R, H_R, alpha_R, &
+                                    vel_R_rms, qR_prim_rs${XYZ}$_vf, j + 1, k, l, 2, c_R)
 
-                                c_R = ((H_R - 5d-1*vel_R_rms)/gamma_R)
-                            end if
+                            !> The computation of c_avg does not require all the variables, and therefore the non '_avg'
+                                    ! variables are placeholders to call the subroutine.
 
-                            if (mixture_err .and. c_L < 0d0) then
-                                c_L = 100.d0*sgm_eps
-                            else
-                                c_L = sqrt(c_L)
-                            end if
-
-                            if (mixture_err .and. c_R < 0d0) then
-                                c_R = 100.d0*sgm_eps
-                            else
-                                c_R = sqrt(c_R)
-                            end if
+                            @:compute_speed_of_sound(pres_R, rho_avg, gamma_avg, pi_inf_R, H_avg, alpha_R, &
+                                vel_avg_rms, qR_prim_rs${XYZ}$_vf, j + 1, k, l, -1, c_avg)
 
                             if (any(Re_size > 0)) then
                                 !$acc loop seq
@@ -1048,6 +989,7 @@ contains
             flux_vf, flux_src_vf, &
             flux_gsrc_vf, &
             norm_dir, ix, iy, iz)
+
         #:for NORM_DIR, XYZ in [(1, 'x'), (2, 'y'), (3, 'z')]
 
             if (norm_dir == ${NORM_DIR}$) then
@@ -1164,58 +1106,17 @@ contains
 
                                 @:compute_average_state()
 
-                                if (mixture_err) then
-                                    if ((H_avg - 5d-1*vel_avg_rms) < 0d0) then
-                                        c_avg = sgm_eps
-                                    else
-
-                                        c_avg = sqrt((H_avg - 5d-1*vel_avg_rms)/gamma_avg)
-                                    end if
-                                else
-
-                                    c_avg = sqrt((H_avg - 5d-1*vel_avg_rms)/gamma_avg)
-                                end if
-
-                                if (alt_soundspeed) then
+                                @:compute_speed_of_sound(pres_L, rho_L, gamma_L, pi_inf_L, H_L, alpha_L, &
+                                    vel_L_rms, qL_prim_rs${XYZ}$_vf, j, k, l, 2, c_L)
 
-                                    blkmod1 = ((gammas(1) + 1d0)*pres_L + &
-                                               pi_infs(1))/gammas(1)
-                                    blkmod2 = ((gammas(2) + 1d0)*pres_L + &
-                                               pi_infs(2))/gammas(2)
-                                    c_L = 1d0/(rho_L*(qL_prim_rs${XYZ}$_vf(j, k, l, E_idx + 1)/blkmod1 &
-                                                      + qL_prim_rs${XYZ}$_vf(j, k, l, E_idx + 2)/blkmod2))
+                                @:compute_speed_of_sound(pres_R, rho_R, gamma_R, pi_inf_R, H_R, alpha_R, &
+                                    vel_R_rms, qR_prim_rs${XYZ}$_vf, j + 1, k, l, 2, c_R)
 
-                                    blkmod1 = ((gammas(1) + 1d0)*pres_R + &
-                                               pi_infs(1))/gammas(1)
-                                    blkmod2 = ((gammas(2) + 1d0)*pres_R + &
-                                               pi_infs(2))/gammas(2)
-                                    c_R = 1d0/(rho_R*(qR_prim_rs${XYZ}$_vf(j + 1, k, l, E_idx + 1)/blkmod1 &
-                                                      + qR_prim_rs${XYZ}$_vf(j + 1, k, l, e_idx + 2)/blkmod2))
-
-                                else
-                                    c_L = 0d0
-                                    c_R = 0d0
-                                    !$acc loop seq
-                                    do i = 1, num_fluids
-                                        c_L = c_L + qL_prim_rs${XYZ}$_vf(j, k, l, i + advxb - 1)*(1d0/gammas(i) + 1d0)* &
-                                              (qL_prim_rs${XYZ}$_vf(j, k, l, E_idx) + pi_infs(i)/(gammas(i) + 1d0))
-                                        c_R = c_R + qR_prim_rs${XYZ}$_vf(j + 1, k, l, i + advxb - 1)*(1d0/gammas(i) + 1d0)* &
-                                              (qR_prim_rs${XYZ}$_vf(j + 1, k, l, E_idx) + pi_infs(i)/(gammas(i) + 1d0))
-                                    end do
-                                    c_L = c_L/rho_L
-                                    c_R = c_R/rho_R
-                                end if
+                                !> The computation of c_avg does not require all the variables, and therefore the non '_avg'
+                                    ! variables are placeholders to call the subroutine.
 
-                                if (mixture_err .and. c_L < 0d0) then
-                                    c_L = 100.d0*sgm_eps
-                                else
-                                    c_L = sqrt(c_L)
-                                end if
-                                if (mixture_err .and. c_R < 0d0) then
-                                    c_R = 100.d0*sgm_eps
-                                else
-                                    c_R = sqrt(c_R)
-                                end if
+                                @:compute_speed_of_sound(pres_R, rho_avg, gamma_avg, pi_inf_R, H_avg, alpha_R, &
+                                    vel_avg_rms, qR_prim_rs${XYZ}$_vf, j + 1, k, l, -1, c_avg)
 
                                 if (any(Re_size > 0)) then
                                     !$acc loop seq
@@ -1472,62 +1373,17 @@ contains
 
                                 @:compute_average_state()
 
-                                if (mixture_err) then
-                                    if ((H_avg - 5d-1*vel_avg_rms) < 0d0) then
-                                        c_avg = sgm_eps
-                                    else
-
-                                        c_avg = sqrt((H_avg - 5d-1*vel_avg_rms)/gamma_avg)
-                                    end if
-                                else
-
-                                    c_avg = sqrt((H_avg - 5d-1*vel_avg_rms)/gamma_avg)
-                                end if
-
-                                if (alt_soundspeed) then
-
-                                    blkmod1 = ((gammas(1) + 1d0)*pres_L + &
-                                               pi_infs(1))/gammas(1)
-                                    blkmod2 = ((gammas(2) + 1d0)*pres_L + &
-                                               pi_infs(2))/gammas(2)
-                                    c_L = 1d0/(rho_L*(alpha_L(1)/blkmod1 + alpha_L(2)/blkmod2))
-
-                                    blkmod1 = ((gammas(1) + 1d0)*pres_R + &
-                                               pi_infs(1))/gammas(1)
-                                    blkmod2 = ((gammas(2) + 1d0)*pres_R + &
-                                               pi_infs(2))/gammas(2)
-                                    c_R = 1d0/(rho_R*(alpha_R(1)/blkmod1 + alpha_R(2)/blkmod2))
+                                @:compute_speed_of_sound(pres_L, rho_L, gamma_L, pi_inf_L, H_L, alpha_L, &
+                                    vel_L_rms, qL_prim_rs${XYZ}$_vf, j, k, l, 1, c_L)
 
-                                else
-                                    ! Sound speed for bubble mmixture to order O(\alpha)
+                                @:compute_speed_of_sound(pres_R, rho_R, gamma_R, pi_inf_R, H_R, alpha_R, &
+                                    vel_R_rms, qR_prim_rs${XYZ}$_vf, j + 1, k, l, 1, c_R)
 
-                                    if (mpp_lim .and. (num_fluids > 1)) then
-                                        c_L = (1d0/gamma_L + 1d0)* &
-                                              (pres_L + pi_inf_L)/rho_L
-                                        c_R = (1d0/gamma_R + 1d0)* &
-                                              (pres_R + pi_inf_R)/rho_R
-                                    else
-                                        c_L = &
-                                            (1d0/gamma_L + 1d0)* &
-                                            (pres_L + pi_inf_L)/ &
-                                            (rho_L*(1d0 - alpha_L(num_fluids)))
-                                        c_R = &
-                                            (1d0/gamma_R + 1d0)* &
-                                            (pres_R + pi_inf_R)/ &
-                                            (rho_R*(1d0 - alpha_R(num_fluids)))
-                                    end if
-                                end if
+                                !> The computation of c_avg does not require all the variables, and therefore the non '_avg'
+                                    ! variables are placeholders to call the subroutine.
 
-                                if (mixture_err .and. c_L < 0d0) then
-                                    c_L = 100.d0*sgm_eps
-                                else
-                                    c_L = sqrt(c_L)
-                                end if
-                                if (mixture_err .and. c_R < 0d0) then
-                                    c_R = 100.d0*sgm_eps
-                                else
-                                    c_R = sqrt(c_R)
-                                end if
+                                @:compute_speed_of_sound(pres_R, rho_avg, gamma_avg, pi_inf_R, H_avg, alpha_R, &
+                                    vel_avg_rms, qR_prim_rs${XYZ}$_vf, j + 1, k, l, -1, c_avg)
 
                                 if (wave_speeds == 1) then
                                     s_L = min(vel_L(dir_idx(1)) - c_L, vel_R(dir_idx(1)) - c_R)
@@ -1701,11 +1557,17 @@ contains
                 
                 elseif (model_eqns == 2 .and. bubbles) then
                     !$acc parallel loop collapse(3) gang vector default(present) private(R0_L, R0_R, V0_L, V0_R, P0_L, P0_R, pbw_L, pbw_R, vel_L, vel_R, & 
-                    !$acc rho_avg, h_avg, gamma_avg, s_L, s_R, s_S, nbub_L, nbub_R, ptilde_L, ptilde_R, vel_avg_rms)
+                    !$acc rho_avg, alpha_L, alpha_R, h_avg, gamma_avg, s_L, s_R, s_S, nbub_L, nbub_R, ptilde_L, ptilde_R, vel_avg_rms)
                     do l = is3%beg, is3%end
                         do k = is2%beg, is2%end
                             do j = is1%beg, is1%end
 
+                                !$acc loop seq
+                                do i = 1, num_fluids
+                                    alpha_L(i) = qL_prim_rs${XYZ}$_vf(j, k, l, E_idx + i)
+                                    alpha_R(i) = qR_prim_rs${XYZ}$_vf(j + 1, k, l, E_idx + i)
+                                end do
+
                                 vel_L_rms = 0d0; vel_R_rms = 0d0
 
                                 !$acc loop seq
@@ -1881,62 +1743,17 @@ contains
 
                                 end if
 
-                                if (mixture_err) then
-                                    if ((H_avg - 5d-1*vel_avg_rms) < 0d0) then
-                                        c_avg = sgm_eps
-                                    else
-
-                                        c_avg = sqrt((H_avg - 5d-1*vel_avg_rms)/gamma_avg)
-                                    end if
-                                else
-
-                                    c_avg = sqrt((H_avg - 5d-1*vel_avg_rms)/gamma_avg)
-                                end if
+                                @:compute_speed_of_sound(pres_L, rho_L, gamma_L, pi_inf_L, H_L, alpha_L, &
+                                    vel_L_rms, qL_prim_rs${XYZ}$_vf, j, k, l, 1, c_L)
 
-                                if (alt_soundspeed) then
+                                @:compute_speed_of_sound(pres_R, rho_R, gamma_R, pi_inf_R, H_R, alpha_R, &
+                                    vel_R_rms, qR_prim_rs${XYZ}$_vf, j + 1, k, l, 1, c_R)
 
-                                    blkmod1 = ((gammas(1) + 1d0)*pres_L + &
-                                               pi_infs(1))/gammas(1)
-                                    blkmod2 = ((gammas(2) + 1d0)*pres_L + &
-                                               pi_infs(2))/gammas(2)
-                                    c_L = 1d0/(rho_L*(qL_prim_rs${XYZ}$_vf(j, k, l, E_idx + 1)/blkmod1 + qL_prim_rs${XYZ}$_vf(j, k, l, E_idx + 2)/blkmod2))
-
-                                    blkmod1 = ((gammas(1) + 1d0)*pres_R + &
-                                               pi_infs(1))/gammas(1)
-                                    blkmod2 = ((gammas(2) + 1d0)*pres_R + &
-                                               pi_infs(2))/gammas(2)
-                                    c_R = 1d0/(rho_R*(qR_prim_rs${XYZ}$_vf(j + 1, k, l,  E_idx + 1)/blkmod1 + qR_prim_rs${XYZ}$_vf(j + 1, k, l,  E_idx + 2)/blkmod2))
-
-                                else
-                                    ! Sound speed for bubble mmixture to order O(\alpha)
-
-                                    if (mpp_lim .and. (num_fluids > 1)) then
-                                        c_L = (1d0/gamma_L + 1d0)* &
-                                              (pres_L + pi_inf_L)/rho_L
-                                        c_R = (1d0/gamma_R + 1d0)* &
-                                              (pres_R + pi_inf_R)/rho_R
-                                    else
-                                        c_L = &
-                                            (1d0/gamma_L + 1d0)* &
-                                            (pres_L + pi_inf_L)/ &
-                                            (rho_L*(1d0 - qL_prim_rs${XYZ}$_vf(j, k, l, E_idx + num_fluids)))
-                                        c_R = &
-                                            (1d0/gamma_R + 1d0)* &
-                                            (pres_R + pi_inf_R)/ &
-                                            (rho_R*(1d0 - qR_prim_rs${XYZ}$_vf(j + 1, k, l, E_idx + num_fluids)))
-                                    end if
-                                end if
+                                !> The computation of c_avg does not require all the variables, and therefore the non '_avg'
+                                    ! variables are placeholders to call the subroutine.
 
-                                if (mixture_err .and. c_L < 0d0) then
-                                    c_L = 100.d0*sgm_eps
-                                else
-                                    c_L = sqrt(c_L)
-                                end if
-                                if (mixture_err .and. c_R < 0d0) then
-                                    c_R = 100.d0*sgm_eps
-                                else
-                                    c_R = sqrt(c_R)
-                                end if
+                                @:compute_speed_of_sound(pres_R, rho_avg, gamma_avg, pi_inf_R, H_avg, alpha_R, &
+                                    vel_avg_rms, qR_prim_rs${XYZ}$_vf, j + 1, k, l, -1, c_avg)
 
                                 if (wave_speeds == 1) then
                                     s_L = min(vel_L(dir_idx(1)) - c_L, vel_R(dir_idx(1)) - c_R)
@@ -2127,12 +1944,18 @@ contains
                     !$acc end parallel loop
                 else
                     !$acc parallel loop collapse(3) gang vector default(present) private(vel_L, vel_R, Re_L, Re_R, &
-                    !$acc rho_avg, h_avg, gamma_avg, s_L, s_R, s_S, vel_avg_rms)
+                    !$acc rho_avg, h_avg, gamma_avg, alpha_L, alpha_R, s_L, s_R, s_S, vel_avg_rms)
                     do l = is3%beg, is3%end
                         do k = is2%beg, is2%end
                             do j = is1%beg, is1%end
                                 idx1 = 1; if (dir_idx(1) == 2) idx1 = 2; if (dir_idx(1) == 3) idx1 = 3
 
+                                !$acc loop seq
+                                do i = 1, num_fluids
+                                    alpha_L(i) = qL_prim_rs${XYZ}$_vf(j, k, l, E_idx + i)
+                                    alpha_R(i) = qR_prim_rs${XYZ}$_vf(j + 1, k, l, E_idx + i)
+                                end do
+
                                 vel_L_rms = 0d0; vel_R_rms = 0d0
                                 !$acc loop seq
                                 do i = 1, num_dims
@@ -2235,50 +2058,17 @@ contains
 
                                 @:compute_average_state()
 
-                                if (mixture_err) then
-                                    if ((H_avg - 5d-1*vel_avg_rms) < 0d0) then
-                                        c_avg = sgm_eps
-                                    else
-
-                                        c_avg = sqrt((H_avg - 5d-1*vel_avg_rms)/gamma_avg)
-                                    end if
-                                else
-
-                                    c_avg = sqrt((H_avg - 5d-1*vel_avg_rms)/gamma_avg)
-                                end if
+                                @:compute_speed_of_sound(pres_L, rho_L, gamma_L, pi_inf_L, H_L, alpha_L, &
+                                    vel_L_rms, qL_prim_rs${XYZ}$_vf, j, k, l, 0, c_L)
 
-                                if (alt_soundspeed) then
+                                @:compute_speed_of_sound(pres_R, rho_R, gamma_R, pi_inf_R, H_R, alpha_R, &
+                                    vel_R_rms, qR_prim_rs${XYZ}$_vf, j + 1, k, l, 0, c_R)
 
-                                    blkmod1 = ((gammas(1) + 1d0)*pres_L + &
-                                               pi_infs(1))/gammas(1)
-                                    blkmod2 = ((gammas(2) + 1d0)*pres_L + &
-                                               pi_infs(2))/gammas(2)
-                                    c_L = 1d0/(rho_L*(qL_prim_rs${XYZ}$_vf(j, k, l, E_idx + 1)/blkmod1 &
-                                                      + qL_prim_rs${XYZ}$_vf(j, k, l, E_idx + 2)/blkmod2))
-
-                                    blkmod1 = ((gammas(1) + 1d0)*pres_R + &
-                                               pi_infs(1))/gammas(1)
-                                    blkmod2 = ((gammas(2) + 1d0)*pres_R + &
-                                               pi_infs(2))/gammas(2)
-                                    c_R = 1d0/(rho_R*(qR_prim_rs${XYZ}$_vf(j + 1, k, l, E_idx + 1)/blkmod1 &
-                                                      + qR_prim_rs${XYZ}$_vf(j + 1, k, l, e_idx + 2)/blkmod2))
-
-                                else
-                                    c_L = ((H_L - 5d-1*vel_L_rms)/gamma_L)
+                                !> The computation of c_avg does not require all the variables, and therefore the non '_avg'
+                                    ! variables are placeholders to call the subroutine.
 
-                                    c_R = ((H_R - 5d-1*vel_R_rms)/gamma_R)
-                                end if
-
-                                if (mixture_err .and. c_L < 0d0) then
-                                    c_L = 100.d0*sgm_eps
-                                else
-                                    c_L = sqrt(c_L)
-                                end if
-                                if (mixture_err .and. c_R < 0d0) then
-                                    c_R = 100.d0*sgm_eps
-                                else
-                                    c_R = sqrt(c_R)
-                                end if
+                                @:compute_speed_of_sound(pres_R, rho_avg, gamma_avg, pi_inf_R, H_avg, alpha_R, &
+                                    vel_avg_rms, qR_prim_rs${XYZ}$_vf, j + 1, k, l, -1, c_avg)
 
                                 if (any(Re_size > 0)) then
                                     !$acc loop seq
diff --git a/src/simulation/m_start_up.fpp b/src/simulation/m_start_up.fpp
index c6e296e..7bbe150 100644
--- a/src/simulation/m_start_up.fpp
+++ b/src/simulation/m_start_up.fpp
@@ -82,7 +82,7 @@ contains
             riemann_solver, wave_speeds, avg_state, &
             bc_x, bc_y, bc_z, &
             hypoelasticity, &
-            fluid_pp, probe_wrt, &
+            fluid_pp, probe_wrt, prim_vars_wrt, &
             fd_order, probe, num_probes, t_step_old, &
             alt_soundspeed, mixture_err, weno_Re_flux, &
             null_weights, precision, parallel_io, cyl_coord, &
diff --git a/toolchain/mfc/run/case_dicts.py b/toolchain/mfc/run/case_dicts.py
index cbd0a66..d2f0857 100644
--- a/toolchain/mfc/run/case_dicts.py
+++ b/toolchain/mfc/run/case_dicts.py
@@ -72,7 +72,7 @@ SIMULATION = COMMON + [
     'mixture_err', 'tvd_riemann_flux', 'tvd_rhs_flux', 'tvd_wave_speeds',
     'flux_lim', 'lsq_deriv', 'fd_order', 'num_probes', 'probe_wrt', 
     'bubble_model', 'Monopole', 'num_mono', 'qbmm', 'R0_type', 'integral_wrt', 
-    'num_integrals', 'cu_mpi'
+    'num_integrals', 'cu_mpi', 'prim_vars_wrt'
 ]
 
 for cmp in ["x", "y", "z"]:
diff --git a/toolchain/mfc/test/case.py b/toolchain/mfc/test/case.py
index df48399..ace1890 100644
--- a/toolchain/mfc/test/case.py
+++ b/toolchain/mfc/test/case.py
@@ -36,7 +36,7 @@ BASE_CFG = {
     'avg_state'                    : 2,
     'format'                       : 1,
     'precision'                    : 2,
-    'prim_vars_wrt'                :'T',
+    'prim_vars_wrt'                :'F',
     'parallel_io'                  :'F',
 
     'patch_icpp(1)%pres'           : 1.0,
